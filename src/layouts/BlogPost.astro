---
import { Head } from '@felixicaza/astro-capo';
import type { CollectionEntry } from 'astro:content';
import { getCFImageUrl, generateCFSrcSet, CF_IMAGE_PRESETS } from '../utils/cloudflare-images';
import BaseHead from '../components/layout/BaseHead.astro';
import Footer from '../components/layout/Footer.astro';
import FormattedDate from '../components/blog/FormattedDate.astro';
import Header from '../components/layout/Header.astro';
import HeaderWrapper from '../components/layout/HeaderWrapper.astro';
import PostNavigation from '../components/blog/PostNavigation.astro';
import Comments from '../components/blog/Comments.astro';
import ShareButtons from '../components/social/ShareButtons.astro';
import TableOfContents from '../components/blog/TableOfContents.astro';
import ReadingTime from '../components/blog/ReadingTime.astro';
import RelatedPosts from '../components/blog/RelatedPosts.astro';
import Breadcrumbs from '../components/navigation/Breadcrumbs.astro';
import { getTagUrl, getTagDisplayName, getTagColorClasses, normalizeTagSlug } from '../utils/tags';
import { EDIT_POST, AUTHOR_NAME, AI_AUTHOR, TAG_METADATA, TAG_AVATAR_MAP } from '../consts';
import { Schema } from 'astro-seo-schema';
import { createBlogPostingSchema, createBreadcrumbSchema } from '../utils/schema';
import { getHeroColors, gradientStylesToString, getGradientStyles } from '../utils/hero-colors';


// Import LightGallery CSS
import 'lightgallery/css/lightgallery.css';
import 'lightgallery/css/lg-zoom.css';
import 'lightgallery/css/lg-thumbnail.css';

import { WebVitals } from '@casoon/astro-webvitals';

export interface Heading {
	depth: number;
	text: string;
	slug: string;
}

type BlogData = CollectionEntry<'blog'>['data'];

interface Props extends BlogData {
	entry?: CollectionEntry<'blog'> | CollectionEntry<'tunes'>;
	previousPost?: CollectionEntry<'blog'> | CollectionEntry<'tunes'>;
	nextPost?: CollectionEntry<'blog'> | CollectionEntry<'tunes'>;
	ogImagePath?: string;
	isTune?: boolean;
	headings?: Heading[];
	filePath?: string;
	readingTime?: number;
}

const { entry, title, description, pubDate, updatedDate, lastModified, heroImage, cover, tags = [], previousPost, nextPost, ogImagePath, isTune = false, showToc = false, headings = [], filePath, readingTime, avatar } = Astro.props;

// Default fallback image
const defaultImage = '/images/blog-cover.png';

// Use the provided OG image path
const ogImage = ogImagePath;

// Use cover.image if available, otherwise fall back to heroImage
// cover.image can be a string (public URL) or an imported image
const displayImage = cover?.image || heroImage;

// Get color palette for hero gradient
const heroColors = getHeroColors(displayImage);
const gradientStyleString = gradientStylesToString(getGradientStyles(heroColors));

// Build edit URL
const editUrl = filePath && EDIT_POST.appendFilePath
	? `${EDIT_POST.url}/${filePath}`
	: EDIT_POST.url;

// Determine author info based on whether this is a tune
const authorName = isTune ? AI_AUTHOR.name : AUTHOR_NAME;

// Build avatar path - support both formats: "coffee" or "coffee.svg" or "coffee.png"
const buildAvatarPath = (avatarName: string | undefined): string | undefined => {
	if (!avatarName) return undefined;

	// If it already has an extension, use as-is
	if (avatarName.includes('.')) {
		return `/images/avatars/${avatarName}`;
	}

	// Default to SVG format
	return `/images/avatars/${avatarName}.svg`;
};

// Get avatar from primary tag if no avatar specified
const getDefaultAvatar = () => {
	if (isTune) return AI_AUTHOR.avatar;
	const primaryTag = tags[0];
	if (primaryTag && TAG_AVATAR_MAP[normalizeTagSlug(primaryTag)]) {
		return `/images/avatars/${TAG_AVATAR_MAP[normalizeTagSlug(primaryTag)]}`;
	}
	return '/images/avatar.svg';
};

const avatarSrc = avatar
	? buildAvatarPath(avatar)
	: getDefaultAvatar();
const avatarFallback = isTune ? AI_AUTHOR.avatarFallback : '/images/avatar-192x192.png';

// Get the primary tag color for avatar glow
const primaryTag = tags[0];
const getAvatarGlowColor = () => {
	if (!primaryTag || !TAG_METADATA[primaryTag]) {
		return 'text-blue-600 dark:text-blue-400';
	}

	const tagColorLight = TAG_METADATA[primaryTag].colorLight;

	// Extract the text color class from tag metadata (e.g., "text-purple-700")
	const textColorMatch = tagColorLight.match(/text-(\w+)-(\d+)/);
	if (textColorMatch) {
		const [, color, shade] = textColorMatch;
		return `text-${color}-${shade} dark:text-${color}-400`;
	}

	return 'text-blue-600 dark:text-blue-400';
};

const avatarGlowColor = getAvatarGlowColor();

// Create BlogPosting schema for SEO
const blogPostingSchema = createBlogPostingSchema({
	title,
	description,
	url: Astro.url.toString(),
	datePublished: pubDate,
	dateModified: lastModified || updatedDate,
	image: ogImage || new URL(defaultImage, Astro.site).toString(),
	author: authorName,
	authorAvatar: avatarSrc,
	keywords: tags,
	siteUrl: Astro.site?.toString() || 'https://www.russ.cloud/'
});

// Build breadcrumb items
const year = pubDate.getFullYear().toString();
const breadcrumbItems = [
	{ label: 'Home', url: '/' },
	{ label: year, url: `/${year}/` },
	{ label: title, url: Astro.url.pathname }
];

// Create BreadcrumbList schema for SEO
const breadcrumbSchema = createBreadcrumbSchema(
	breadcrumbItems.map(item => ({ name: item.label, url: item.url })),
	Astro.site?.toString() || 'https://www.russ.cloud/'
);
---

<html lang="en">
	<Head>
		<BaseHead
			title={title}
			description={description}
			image={ogImage}
			datePublished={pubDate}
			dateModified={updatedDate}
			lastModified={lastModified}
			author={authorName}
			keywords={tags}
		/>
		<!-- Preload hero image for LCP optimization -->
		{displayImage && (
			<link
				rel="preload"
				as="image"
				href={getCFImageUrl(displayImage, {
					width: 1920,
					quality: CF_IMAGE_PRESETS.hero.quality,
					format: CF_IMAGE_PRESETS.hero.format,
					fit: CF_IMAGE_PRESETS.hero.fit
				})}
				imagesrcset={generateCFSrcSet(displayImage, CF_IMAGE_PRESETS.hero.widths, CF_IMAGE_PRESETS.hero.quality, CF_IMAGE_PRESETS.hero.format)}
				imagesizes="(max-width: 640px) calc(100vw - 32px), (max-width: 1024px) calc(100vw - 48px), 1100px"
				fetchpriority="high"
			/>
		)}
		<!-- Preconnect to Giscus for faster comment loading (only on blog posts) -->
		<link rel="dns-prefetch" href="https://giscus.app">
		<link rel="preconnect" href="https://giscus.app" crossorigin>
		<!-- Preconnect to GitHub for faster asset/embed loading -->
		<link rel="dns-prefetch" href="https://github.githubassets.com">
		<link rel="dns-prefetch" href="https://opengraph.githubassets.com">
		<Schema item={blogPostingSchema} />
		<Schema item={breadcrumbSchema} />
	</Head>

	<body class="bg-gray-50 dark:bg-gray-950">
		<HeaderWrapper autoHide={false}>
			<Header transparent={false} />
		</HeaderWrapper>
		<main class="relative">
			{/* Dynamic gradient section - soft color wash behind content */}
			<section
				class="hero-gradient-section absolute inset-x-0 top-0 -mt-16 h-[70vh] min-h-[450px]"
				style={gradientStyleString}
			>
				<div class="hero-gradient-bg absolute inset-0"></div>
			</section>

			{/* Post card - positioned below nav with gap */}
			<article class="relative z-10 pt-20 sm:pt-24">
				<div class="max-w-4xl 2xl:max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 xl:px-10">
					<div class="bg-white dark:bg-gray-900 rounded-3xl shadow-2xl shadow-gray-300/40 dark:shadow-black/60 ring-1 ring-gray-200/60 dark:ring-gray-800 overflow-hidden">
						{/* Hero image inside the card - edge to edge with rounded top corners */}
						{displayImage && (
							<div class="relative mb-2">
								<img
									src={getCFImageUrl(displayImage, {
										width: 1920,
										quality: CF_IMAGE_PRESETS.hero.quality,
										format: CF_IMAGE_PRESETS.hero.format,
										fit: 'scale-down'
									})}
									srcset={generateCFSrcSet(displayImage, CF_IMAGE_PRESETS.hero.widths, CF_IMAGE_PRESETS.hero.quality, CF_IMAGE_PRESETS.hero.format)}
									sizes="(max-width: 640px) calc(100vw - 32px), (max-width: 1024px) calc(100vw - 48px), 1100px"
									alt={cover?.alt || title}
									loading="eager"
									fetchpriority="high"
									decoding="sync"
									width="2048"
									height="1143"
									class="hero-image-card w-full h-auto rounded-t-3xl"
								/>
								{/* Shadow at bottom of image only */}
								<div class="absolute inset-x-0 bottom-0 h-20 bg-gradient-to-t from-black/25 to-transparent pointer-events-none"></div>
							</div>
						)}

						<div class="px-6 sm:px-10 xl:px-16 py-8 sm:py-10 xl:py-12">
							<Breadcrumbs items={breadcrumbItems} />

						<header class="text-center mb-10 space-y-6">
							<h1 class="text-4xl sm:text-5xl lg:text-6xl font-extrabold leading-tight tracking-tight text-gray-900 dark:text-gray-100" style="font-size: clamp(2.25rem, 5vw, 3.75rem);">
								{title}
							</h1>

							<!-- Enhanced Author Info Box -->
							<div class="bg-blue-50/50 dark:bg-blue-950/20 backdrop-blur-sm border border-blue-200/60 dark:border-blue-800/40 rounded-2xl p-5 shadow-sm">
								<div class="flex items-start gap-4">
									<!-- Avatar Section -->
									<div class="relative flex-shrink-0">
										<div class={`absolute -inset-0.5 bg-gradient-to-r from-current to-current rounded-full opacity-60 blur-sm ${avatarGlowColor}`}></div>
										<img
											src={avatarSrc}
											alt={authorName}
											class="relative w-16 h-16 rounded-full ring-3 ring-white dark:ring-gray-900 shadow-md object-cover"
											onerror={`this.onerror=null; this.src='${avatarFallback}';`}
										/>
									</div>

									<!-- Info Section -->
									<div class="flex-1 min-w-0 space-y-2.5">
										<!-- Author Name & Meta Info (same line) -->
										<div class="flex flex-wrap items-center gap-x-3 gap-y-1">
											<span class="font-bold text-lg text-gray-900 dark:text-gray-100">
												{authorName}
											</span>
											<span class="flex items-center gap-1.5 text-sm text-gray-600 dark:text-gray-400">
												<svg class="w-3.5 h-3.5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
												</svg>
												<FormattedDate date={pubDate} />
											</span>
											{readingTime && (
												<>
													<span class="text-gray-400 dark:text-gray-600 text-sm">•</span>
													<span class="flex items-center gap-1.5 text-sm text-gray-600 dark:text-gray-400">
														<svg class="w-3.5 h-3.5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
															<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
														</svg>
														<ReadingTime minutes={readingTime} />
													</span>
												</>
											)}
											{filePath && (
												<>
													<span class="text-gray-400 dark:text-gray-600 text-sm">•</span>
													<a
														href={editUrl}
														rel="noopener noreferrer edit"
														target="_blank"
														class="hover:text-blue-600 dark:hover:text-blue-400 transition-colors inline-flex items-center gap-1.5 text-sm font-medium text-gray-600 dark:text-gray-400"
													>
														<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
															<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
														</svg>
														{EDIT_POST.text}
													</a>
												</>
											)}
										</div>

										<!-- Tags -->
										{tags.length > 0 && (
											<div class="flex flex-wrap gap-2">
												{tags.slice(0, 8).map((tag) => (
													<a
														href={getTagUrl(tag)}
														class={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${getTagColorClasses(tag)} transition-all hover:scale-105 hover:shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500/50`}
														onclick="event.stopPropagation()"
													>
														{getTagDisplayName(tag)}
													</a>
												))}
											</div>
										)}

										<!-- Updated Date -->
										{updatedDate && (
											<div class="text-xs text-gray-600 dark:text-gray-400 italic">
												Last updated: <FormattedDate date={updatedDate} />
											</div>
										)}
									</div>
								</div>
							</div>
						</header>

						{showToc && headings.length > 0 && (
							<TableOfContents headings={headings} />
						)}

						<div class="prose mx-auto">
							<slot />
						</div>

						{!isTune && <ShareButtons title={title} url={Astro.url.href} tags={tags} />}

						{!isTune && entry && <RelatedPosts currentPost={entry} previousPost={previousPost} nextPost={nextPost} limit={3} />}
						</div>
					</div>

					<PostNavigation previousPost={previousPost} nextPost={nextPost} />

					{!isTune && <Comments />}
				</div>
			</article>
		</main>
		<Footer />
		<WebVitals debug={import.meta.env.DEV} />
		<script>
			import type { LightGallerySettings } from 'lightgallery/lg-settings';
			import type { AstroLightGalleryPluginStrType } from 'astro-lightgallery';

			// Guard to prevent concurrent initializations
			let isInitializing = false;

			// Initialize LightGallery for blog post pages with optimized DOM operations
			async function initLightGallery() {
				if (isInitializing) return;
				isInitializing = true;

				try {
					// Use requestAnimationFrame to batch DOM reads and avoid forced reflows
					await new Promise<void>(resolve => {
						requestAnimationFrame(async () => {
							const galleries = document.querySelectorAll('astro-lightgallery, .lightgallery-component');

							// Early exit if no galleries - don't load the library at all
							if (galleries.length === 0) {
								resolve();
								return;
							}

							// Dynamic import - only load LightGallery when galleries exist
							const { default: lightGallery } = await import('lightgallery');
							const { default: lgThumbnail } = await import('lightgallery/plugins/thumbnail');
							const { default: lgZoom } = await import('lightgallery/plugins/zoom');

							// Batch all DOM reads first to avoid layout thrashing
							const galleryData: Array<{
								htmlGallery: HTMLElement;
								items: HTMLElement[];
								options?: LightGallerySettings;
							}> = [];

							let firstGalleryOptions: LightGallerySettings = {};
							let foundFullGalleryOptions = false;

							for (const gallery of galleries) {
								const htmlGallery = gallery as HTMLElement;

								// Skip if already initialized by THIS script
								if (htmlGallery.hasAttribute('data-unified-initialized')) {
									continue;
								}

								// Read options logic:
								// 1. If we haven't found options from a "full gallery" yet, check this one.
								// 2. If this IS a full gallery (has lightgallery-wrapper), it overrides any previous options (even if we already found some from a single image).
								const isFullGallery = htmlGallery.classList.contains('lightgallery-wrapper');
								
								if (!foundFullGalleryOptions) {
									// If we haven't found a full gallery yet, we can take options from this one
									// But if THIS one is a full gallery, we mark it so we don't get overridden by a later single image
									if (galleryData.length === 0 || isFullGallery) {
										const optionsStr = htmlGallery.getAttribute('data-options') || htmlGallery.dataset.options || '{}';
										try {
											const parsedOptions = JSON.parse(optionsStr);
											// Only update if it's the first one OR if it's a full gallery overriding a previous one
											if (galleryData.length === 0 || isFullGallery) {
												firstGalleryOptions = parsedOptions;
											}
											if (isFullGallery) {
												foundFullGalleryOptions = true;
											}
										} catch (e) {
											console.warn('Failed to parse gallery options', e);
										}
									}
								}

								// Collect all items
								const items = Array.from(htmlGallery.querySelectorAll<HTMLElement>('a[data-lg-id]'));

								galleryData.push({
									htmlGallery,
									items,
									options: firstGalleryOptions // This might be slightly stale for the pushed item if a later gallery overrides it, but we only use `firstGalleryOptions` at the end for the unified instance anyway.
								});
							}

							// Now do all DOM writes in a single batch
							if (galleryData.length > 0) {
								// Flatten all items
								const allGalleryItems = galleryData.flatMap(g => g.items);

								if (allGalleryItems.length === 0) {
									resolve();
									return;
								}

								// Create unified gallery container
								const unifiedGalleryId = 'unified-lightgallery';
								let unifiedGallery = document.getElementById(unifiedGalleryId);

								if (unifiedGallery) {
									// If it exists, clear it out to be safe
									unifiedGallery.innerHTML = '';
								} else {
									unifiedGallery = document.createElement('div');
									unifiedGallery.id = unifiedGalleryId;
									// Use visibility hidden instead of display none to ensure events/dimensions work if needed
									unifiedGallery.style.position = 'absolute';
									unifiedGallery.style.top = '0';
									unifiedGallery.style.left = '0';
									unifiedGallery.style.width = '0';
									unifiedGallery.style.height = '0';
									unifiedGallery.style.visibility = 'hidden';
									unifiedGallery.style.overflow = 'hidden';
									document.body.appendChild(unifiedGallery);
								}

								// Populate unified gallery
								const fragment = document.createDocumentFragment();
								allGalleryItems.forEach(item => {
									const clone = item.cloneNode(true) as HTMLElement;
									fragment.appendChild(clone);
								});
								unifiedGallery.appendChild(fragment);

								// Mark galleries as initialized
								galleryData.forEach(({ htmlGallery }) => {
									htmlGallery.setAttribute('data-unified-initialized', 'true');
								});

								// Initialize unified gallery
								// Merge plugins into options
								const lgOptions = {
									...firstGalleryOptions,
									plugins: [lgThumbnail, lgZoom],
									selector: 'a[data-lg-id]', // Explicitly select items
									licenseKey: '0000-0000-000-0000' // Open source license
								};

								const galleryInstance = lightGallery(unifiedGallery, lgOptions);

								// Redirect clicks from original galleries to unified gallery
								// CRITICAL: Clone and replace items to strip any existing event listeners (e.g. from astro-lightgallery auto-init)
								allGalleryItems.forEach((item, index) => {
									const newItem = item.cloneNode(true) as HTMLElement;
									if (item.parentNode) {
										item.parentNode.replaceChild(newItem, item);
									}
									
									newItem.addEventListener('click', (e) => {
										e.preventDefault();
										e.stopPropagation(); // Stop propagation to be safe
										
										if (galleryInstance && typeof galleryInstance.openGallery === 'function') {
											galleryInstance.openGallery(index);
										} else {
											console.warn('[LightGallery] Instance not found or openGallery missing, falling back to click simulation');
											const unifiedItems = unifiedGallery!.querySelectorAll('a[data-lg-id]');
											if (unifiedItems[index]) {
												(unifiedItems[index] as HTMLElement).click();
											}
										}
									});
								});
							}
							resolve();
						});
					});
				} finally {
					isInitializing = false;
				}
			}

			// Initialize on first load
			initLightGallery();

			// Re-initialize after View Transitions navigation (cleanup is handled globally in BaseLayout)
			document.addEventListener('astro:page-load', () => {
				// Use requestIdleCallback for better performance, fallback to microtask
				if ('requestIdleCallback' in window) {
					requestIdleCallback(() => initLightGallery(), { timeout: 2000 });
				} else {
					Promise.resolve().then(() => initLightGallery());
				}
			});
		</script>
		<script>
			// Fix accessibility: Ensure scrollable code blocks have tabindex
			// Expressive Code removes tabindex dynamically if content isn't scrollable at check time
			// We re-add it after a delay to ensure keyboard accessibility
			function fixCodeBlockTabindex() {
				const preElements = document.querySelectorAll('.expressive-code pre');
				const elementsToFix: HTMLElement[] = [];

				// Batch reads
				preElements.forEach(pre => {
					// Check if content is scrollable (width overflow)
					if (pre.scrollWidth > pre.clientWidth && !pre.hasAttribute('tabindex')) {
						elementsToFix.push(pre as HTMLElement);
					}
				});

				// Batch writes
				elementsToFix.forEach(pre => {
					pre.setAttribute('tabindex', '0');
					pre.setAttribute('role', 'region');
				});
			}

			// Run after Expressive Code's debounced observer (250ms + idle callback)
			setTimeout(fixCodeBlockTabindex, 600);
			setTimeout(fixCodeBlockTabindex, 1500);
			window.addEventListener('load', () => setTimeout(fixCodeBlockTabindex, 300));
			document.addEventListener('astro:page-load', () => setTimeout(fixCodeBlockTabindex, 500));
		</script>
	</body>
</html>
