---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import { ViewTransitions } from 'astro:transitions';
import BaseHead from '../components/layout/BaseHead.astro';
import Footer from '../components/layout/Footer.astro';
import FormattedDate from '../components/blog/FormattedDate.astro';
import Header from '../components/layout/Header.astro';
import HeaderWrapper from '../components/layout/HeaderWrapper.astro';
import PostNavigation from '../components/blog/PostNavigation.astro';
import Comments from '../components/blog/Comments.astro';
import ShareButtons from '../components/social/ShareButtons';
import TableOfContents from '../components/blog/TableOfContents.astro';
import ReadingTime from '../components/blog/ReadingTime.astro';
import RelatedPosts from '../components/blog/RelatedPosts.astro';
import Breadcrumbs from '../components/navigation/Breadcrumbs.astro';
import { getTagUrl, getTagDisplayName, getTagColorClasses } from '../utils/tags';
import { EDIT_POST, AUTHOR_NAME, AI_AUTHOR, TAG_METADATA } from '../consts';
import { Schema } from 'astro-seo-schema';
import { createBlogPostingSchema, createBreadcrumbSchema } from '../utils/schema';

// Import embed components to make them available in blog posts
import { YouTube } from '@astro-community/astro-embed-youtube';
import { LinkPreview } from '@astro-community/astro-embed-link-preview';

export interface Heading {
	depth: number;
	text: string;
	slug: string;
}

interface Props extends CollectionEntry<'blog'>['data'] {
	entry?: CollectionEntry<'blog'>;
	previousPost?: CollectionEntry<'blog'>;
	nextPost?: CollectionEntry<'blog'>;
	ogImagePath?: string;
	isTune?: boolean;
	headings?: Heading[];
	filePath?: string;
	readingTime?: number;
}

const { entry, title, description, pubDate, updatedDate, lastModified, heroImage, cover, tags = [], previousPost, nextPost, ogImagePath, isTune = false, showToc = false, headings = [], filePath, readingTime, avatar } = Astro.props;

// Default fallback image
const defaultImage = '/images/blog-cover.png';

// Use the provided OG image path
const ogImage = ogImagePath;

// Use cover.image if available, otherwise fall back to heroImage
// cover.image can be a string (public URL) or an imported image
const displayImage = cover?.image || heroImage;

// Build edit URL
const editUrl = filePath && EDIT_POST.appendFilePath
	? `${EDIT_POST.url}/${filePath}`
	: EDIT_POST.url;

// Determine author info based on whether this is a tune
const authorName = isTune ? AI_AUTHOR.name : AUTHOR_NAME;

// Build avatar path - support both formats: "coffee" or "coffee.svg" or "coffee.png"
const buildAvatarPath = (avatarName: string | undefined) => {
	if (!avatarName) return null;

	// If it already has an extension, use as-is
	if (avatarName.includes('.')) {
		return `/images/avatars/${avatarName}`;
	}

	// Default to SVG format
	return `/images/avatars/${avatarName}.svg`;
};

const avatarSrc = avatar
	? buildAvatarPath(avatar)
	: (isTune ? AI_AUTHOR.avatar : '/images/avatar.svg');
const avatarFallback = isTune ? AI_AUTHOR.avatarFallback : '/images/avatar-192x192.png';

// Get the primary tag color for avatar glow
const primaryTag = tags[0];
const getAvatarGlowColor = () => {
	if (!primaryTag || !TAG_METADATA[primaryTag]) {
		return 'text-blue-600 dark:text-blue-400';
	}

	const tagColorLight = TAG_METADATA[primaryTag].colorLight;

	// Extract the text color class from tag metadata (e.g., "text-purple-700")
	const textColorMatch = tagColorLight.match(/text-(\w+)-(\d+)/);
	if (textColorMatch) {
		const [, color, shade] = textColorMatch;
		return `text-${color}-${shade} dark:text-${color}-400`;
	}

	return 'text-blue-600 dark:text-blue-400';
};

const avatarGlowColor = getAvatarGlowColor();

// Create BlogPosting schema for SEO
const blogPostingSchema = createBlogPostingSchema({
	title,
	description,
	url: Astro.url.toString(),
	datePublished: pubDate,
	dateModified: lastModified || updatedDate,
	image: ogImage || new URL(defaultImage, Astro.site).toString(),
	author: authorName,
	authorAvatar: avatarSrc,
	keywords: tags,
	siteUrl: Astro.site?.toString() || 'https://www.russ.cloud/'
});

// Build breadcrumb items
const year = pubDate.getFullYear().toString();
const breadcrumbItems = [
	{ label: 'Home', url: '/' },
	{ label: year, url: `/${year}/` },
	{ label: title, url: Astro.url.pathname }
];

// Create BreadcrumbList schema for SEO
const breadcrumbSchema = createBreadcrumbSchema(
	breadcrumbItems.map(item => ({ name: item.label, url: item.url })),
	Astro.site?.toString() || 'https://www.russ.cloud/'
);
---

<html lang="en">
	<head>
		<BaseHead
			title={title}
			description={description}
			image={ogImage}
			datePublished={pubDate}
			dateModified={updatedDate}
			lastModified={lastModified}
			author={authorName}
			keywords={tags}
		/>
		<ViewTransitions />
		<Schema item={blogPostingSchema} />
		<Schema item={breadcrumbSchema} />
	</head>

	<body class="bg-gray-50 dark:bg-gray-950">
		<HeaderWrapper autoHide={false} transition:persist="site-header">
			<Header />
		</HeaderWrapper>
		<main class="relative" transition:animate="fade">
			{displayImage && (
				<section class="relative isolate -mt-20">
					<div class="relative h-[420px] sm:h-[520px] lg:h-[640px] xl:h-[720px] 2xl:h-[820px] overflow-hidden">
						<Image
							src={displayImage}
							alt={cover?.alt || title}
							widths={[640, 1024, 1280, 1920]}
							sizes="100vw"
							loading="eager"
							fetchpriority="high"
							quality={65}
							format="webp"
							class="absolute inset-0 h-full w-full object-cover"
						/>
					<div class="absolute inset-0 bg-gradient-to-b from-black/25 via-black/10 to-transparent dark:from-black/40 dark:via-black/25"></div>
					<div class="absolute inset-0 bg-gradient-to-t from-transparent via-white/10 to-white/30 dark:via-white/5 dark:to-white/10 mix-blend-screen"></div>
					</div>
					<div class="pointer-events-none absolute inset-x-0 bottom-0 h-40 xl:h-52 2xl:h-60 bg-gradient-to-b from-transparent via-gray-50/60 to-gray-50 dark:via-gray-950/60 dark:to-gray-950"></div>
				</section>
			)}

			<article class={`relative z-10 ${displayImage ? '-mt-32 sm:-mt-40 lg:-mt-48 xl:-mt-60 2xl:-mt-72' : 'mt-12'}`}>
				<div class="max-w-4xl 2xl:max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 xl:px-10">
					<div class="bg-white/95 dark:bg-gray-900/90 rounded-3xl shadow-2xl shadow-gray-300/40 dark:shadow-black/60 ring-1 ring-gray-200/60 dark:ring-gray-800 backdrop-blur-xl px-6 sm:px-10 xl:px-16 py-10 sm:py-12 xl:py-16">
						<Breadcrumbs items={breadcrumbItems} />

						<header class="text-center mb-10 space-y-6">
							<h1 class="text-4xl sm:text-5xl lg:text-6xl font-extrabold leading-tight tracking-tight text-gray-900 dark:text-gray-100">
								{title}
							</h1>

							<!-- Enhanced Author Info Box -->
							<div class="bg-blue-50/50 dark:bg-blue-950/20 backdrop-blur-sm border border-blue-200/60 dark:border-blue-800/40 rounded-2xl p-5 shadow-sm">
								<div class="flex items-start gap-4">
									<!-- Avatar Section -->
									<div class="relative flex-shrink-0">
										<div class={`absolute -inset-0.5 bg-gradient-to-r from-current to-current rounded-full opacity-60 blur-sm ${avatarGlowColor}`}></div>
										<img
											src={avatarSrc}
											alt={authorName}
											class="relative w-16 h-16 rounded-full ring-3 ring-white dark:ring-gray-900 shadow-md object-cover"
											onError={`this.onerror=null; this.src='${avatarFallback}';`}
										/>
									</div>

									<!-- Info Section -->
									<div class="flex-1 min-w-0 space-y-2.5">
										<!-- Author Name & Meta Info (same line) -->
										<div class="flex flex-wrap items-center gap-x-3 gap-y-1">
											<span class="font-bold text-lg text-gray-900 dark:text-gray-100">
												{authorName}
											</span>
											<span class="flex items-center gap-1.5 text-sm text-gray-600 dark:text-gray-400">
												<svg class="w-3.5 h-3.5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
												</svg>
												<FormattedDate date={pubDate} />
											</span>
											{readingTime && (
												<>
													<span class="text-gray-400 dark:text-gray-600 text-sm">•</span>
													<span class="flex items-center gap-1.5 text-sm text-gray-600 dark:text-gray-400">
														<svg class="w-3.5 h-3.5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
															<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
														</svg>
														<ReadingTime minutes={readingTime} />
													</span>
												</>
											)}
											{filePath && (
												<>
													<span class="text-gray-400 dark:text-gray-600 text-sm">•</span>
													<a
														href={editUrl}
														rel="noopener noreferrer edit"
														target="_blank"
														class="hover:text-blue-600 dark:hover:text-blue-400 transition-colors inline-flex items-center gap-1.5 text-sm font-medium text-gray-600 dark:text-gray-400"
													>
														<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
															<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
														</svg>
														{EDIT_POST.text}
													</a>
												</>
											)}
										</div>

										<!-- Tags -->
										{tags.length > 0 && (
											<div class="flex flex-wrap gap-2">
												{tags.slice(0, 8).map((tag) => (
													<a
														href={getTagUrl(tag)}
														class={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${getTagColorClasses(tag)} transition-all hover:scale-105 hover:shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500/50`}
														onclick="event.stopPropagation()"
													>
														{getTagDisplayName(tag)}
													</a>
												))}
											</div>
										)}

										<!-- Updated Date -->
										{updatedDate && (
											<div class="text-xs text-gray-600 dark:text-gray-400 italic">
												Last updated: <FormattedDate date={updatedDate} />
											</div>
										)}
									</div>
								</div>
							</div>
						</header>

						{showToc && headings.length > 0 && (
							<TableOfContents headings={headings} />
						)}

						<div class="prose mx-auto">
							<slot />
						</div>

						{!isTune && <ShareButtons client:visible title={title} url={Astro.url.href} tags={tags} />}

						{!isTune && entry && <RelatedPosts currentPost={entry} previousPost={previousPost} nextPost={nextPost} limit={3} />}
					</div>

					<PostNavigation previousPost={previousPost} nextPost={nextPost} />

					{!isTune && <Comments />}
				</div>
			</article>
		</main>
		<Footer transition:persist="site-footer" />
		<script>
			import { createLightGallery } from 'astro-lightgallery';
			import type { LightGallerySettings } from 'lightgallery/lg-settings';
			import type { AstroLightGalleryPluginStrType } from 'astro-lightgallery';

			// Initialize LightGallery for blog post pages
			async function initLightGallery() {
				const galleries = document.querySelectorAll('astro-lightgallery');

				// Collect all gallery items across all galleries
				const allGalleryItems: HTMLElement[] = [];
				const galleryOptions: LightGallerySettings = {};
				let addPlugins: AstroLightGalleryPluginStrType[] = [];

				for (const gallery of galleries) {
					const htmlGallery = gallery as HTMLElement;

					// Skip if already initialized on this page load
					if (htmlGallery.hasAttribute('data-lg-initialized')) {
						continue;
					}

					// Collect options from first gallery
					if (allGalleryItems.length === 0) {
						const options = JSON.parse(htmlGallery.dataset.options || '{}');
						Object.assign(galleryOptions, options);
						addPlugins = JSON.parse(htmlGallery.dataset.addplugins || '[]');
					}

					// Collect all gallery items
					const items = htmlGallery.querySelectorAll<HTMLElement>('a[data-lg-id]');
					allGalleryItems.push(...Array.from(items));

					// Mark as initialized
					htmlGallery.setAttribute('data-lg-initialized', 'true');
				}

				// If we have items, create a single unified gallery
				if (allGalleryItems.length > 0) {
					// Create a wrapper for all items
					const unifiedGalleryId = 'unified-lightgallery';
					let unifiedGallery = document.getElementById(unifiedGalleryId);

					if (!unifiedGallery) {
						unifiedGallery = document.createElement('div');
						unifiedGallery.id = unifiedGalleryId;
						unifiedGallery.style.display = 'none';
						document.body.appendChild(unifiedGallery);
					}

					// Clear and populate unified gallery
					unifiedGallery.innerHTML = '';
					allGalleryItems.forEach(item => {
						const clone = item.cloneNode(true) as HTMLElement;
						unifiedGallery!.appendChild(clone);
					});

					// Initialize unified gallery
					await createLightGallery(unifiedGalleryId, galleryOptions, addPlugins);

					// Redirect clicks from original galleries to unified gallery
					allGalleryItems.forEach((item, index) => {
						item.addEventListener('click', (e) => {
							e.preventDefault();
							const unifiedItems = unifiedGallery!.querySelectorAll('a[data-lg-id]');
							if (unifiedItems[index]) {
								(unifiedItems[index] as HTMLElement).click();
							}
						});
					});
				}
			}

			// Initialize on first load
			initLightGallery();

			// Re-initialize after View Transitions navigation (cleanup is handled globally in BaseLayout)
			document.addEventListener('astro:page-load', () => {
				// Small delay to ensure DOM is ready
				setTimeout(() => initLightGallery(), 100);
			});
		</script>
	</body>
</html>
