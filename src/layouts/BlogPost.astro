---
import type { CollectionEntry } from 'astro:content';
import { getCFImageUrl, generateCFSrcSet, CF_IMAGE_PRESETS } from '../utils/cloudflare-images';
import BaseHead from '../components/layout/BaseHead.astro';
import Footer from '../components/layout/Footer.astro';
import FormattedDate from '../components/blog/FormattedDate.astro';
import Header from '../components/layout/Header.astro';
import HeaderWrapper from '../components/layout/HeaderWrapper.astro';
import PostNavigation from '../components/blog/PostNavigation.astro';
import Comments from '../components/blog/Comments.astro';
import ShareButtons from '../components/social/ShareButtons.astro';
import TableOfContents from '../components/blog/TableOfContents.astro';
import ReadingTime from '../components/blog/ReadingTime.astro';
import RelatedPosts from '../components/blog/RelatedPosts.astro';
import Breadcrumbs from '../components/navigation/Breadcrumbs.astro';
import { getTagUrl, getTagDisplayName, getTagColorClasses, normalizeTagSlug } from '../utils/tags';
import { EDIT_POST, AUTHOR_NAME, AI_AUTHOR, TAG_METADATA, TAG_AVATAR_MAP } from '../consts';
import { Schema } from 'astro-seo-schema';
import { createBlogPostingSchema, createBreadcrumbSchema } from '../utils/schema';

// Import embed components to make them available in blog posts
import { YouTube } from '@astro-community/astro-embed-youtube';
import { LinkPreview } from '@astro-community/astro-embed-link-preview';

export interface Heading {
	depth: number;
	text: string;
	slug: string;
}

interface Props extends CollectionEntry<'blog'>['data'] {
	entry?: CollectionEntry<'blog'>;
	previousPost?: CollectionEntry<'blog'>;
	nextPost?: CollectionEntry<'blog'>;
	ogImagePath?: string;
	isTune?: boolean;
	headings?: Heading[];
	filePath?: string;
	readingTime?: number;
}

const { entry, title, description, pubDate, updatedDate, lastModified, heroImage, cover, tags = [], previousPost, nextPost, ogImagePath, isTune = false, showToc = false, headings = [], filePath, readingTime, avatar } = Astro.props;

// Default fallback image
const defaultImage = '/images/blog-cover.png';

// Use the provided OG image path
const ogImage = ogImagePath;

// Use cover.image if available, otherwise fall back to heroImage
// cover.image can be a string (public URL) or an imported image
const displayImage = cover?.image || heroImage;

// Build edit URL
const editUrl = filePath && EDIT_POST.appendFilePath
	? `${EDIT_POST.url}/${filePath}`
	: EDIT_POST.url;

// Determine author info based on whether this is a tune
const authorName = isTune ? AI_AUTHOR.name : AUTHOR_NAME;

// Build avatar path - support both formats: "coffee" or "coffee.svg" or "coffee.png"
const buildAvatarPath = (avatarName: string | undefined) => {
	if (!avatarName) return null;

	// If it already has an extension, use as-is
	if (avatarName.includes('.')) {
		return `/images/avatars/${avatarName}`;
	}

	// Default to SVG format
	return `/images/avatars/${avatarName}.svg`;
};

// Get avatar from primary tag if no avatar specified
const getDefaultAvatar = () => {
	if (isTune) return AI_AUTHOR.avatar;
	const primaryTag = tags[0];
	if (primaryTag && TAG_AVATAR_MAP[normalizeTagSlug(primaryTag)]) {
		return `/images/avatars/${TAG_AVATAR_MAP[normalizeTagSlug(primaryTag)]}`;
	}
	return '/images/avatar.svg';
};

const avatarSrc = avatar
	? buildAvatarPath(avatar)
	: getDefaultAvatar();
const avatarFallback = isTune ? AI_AUTHOR.avatarFallback : '/images/avatar-192x192.png';

// Get the primary tag color for avatar glow
const primaryTag = tags[0];
const getAvatarGlowColor = () => {
	if (!primaryTag || !TAG_METADATA[primaryTag]) {
		return 'text-blue-600 dark:text-blue-400';
	}

	const tagColorLight = TAG_METADATA[primaryTag].colorLight;

	// Extract the text color class from tag metadata (e.g., "text-purple-700")
	const textColorMatch = tagColorLight.match(/text-(\w+)-(\d+)/);
	if (textColorMatch) {
		const [, color, shade] = textColorMatch;
		return `text-${color}-${shade} dark:text-${color}-400`;
	}

	return 'text-blue-600 dark:text-blue-400';
};

const avatarGlowColor = getAvatarGlowColor();

// Create BlogPosting schema for SEO
const blogPostingSchema = createBlogPostingSchema({
	title,
	description,
	url: Astro.url.toString(),
	datePublished: pubDate,
	dateModified: lastModified || updatedDate,
	image: ogImage || new URL(defaultImage, Astro.site).toString(),
	author: authorName,
	authorAvatar: avatarSrc,
	keywords: tags,
	siteUrl: Astro.site?.toString() || 'https://www.russ.cloud/'
});

// Build breadcrumb items
const year = pubDate.getFullYear().toString();
const breadcrumbItems = [
	{ label: 'Home', url: '/' },
	{ label: year, url: `/${year}/` },
	{ label: title, url: Astro.url.pathname }
];

// Create BreadcrumbList schema for SEO
const breadcrumbSchema = createBreadcrumbSchema(
	breadcrumbItems.map(item => ({ name: item.label, url: item.url })),
	Astro.site?.toString() || 'https://www.russ.cloud/'
);
---

<html lang="en">
	<head>
		<BaseHead
			title={title}
			description={description}
			image={ogImage}
			datePublished={pubDate}
			dateModified={updatedDate}
			lastModified={lastModified}
			author={authorName}
			keywords={tags}
		/>
		<!-- Preload hero image for LCP optimization -->
		{displayImage && (
			<link
				rel="preload"
				as="image"
				href={getCFImageUrl(displayImage, {
					width: 1920,
					quality: CF_IMAGE_PRESETS.hero.quality,
					format: CF_IMAGE_PRESETS.hero.format,
					fit: CF_IMAGE_PRESETS.hero.fit
				})}
				imagesrcset={generateCFSrcSet(displayImage, CF_IMAGE_PRESETS.hero.widths, CF_IMAGE_PRESETS.hero.quality, CF_IMAGE_PRESETS.hero.format)}
				imagesizes="100vw"
				fetchpriority="high"
			/>
		)}
		<Schema item={blogPostingSchema} />
		<Schema item={breadcrumbSchema} />
	</head>

	<body class="bg-gray-50 dark:bg-gray-950">
		<HeaderWrapper autoHide={false}>
			<Header />
		</HeaderWrapper>
		<main class="relative">
			{displayImage && (
				<section class="relative isolate -mt-20">
					<div class="relative h-[420px] sm:h-[520px] lg:h-[640px] xl:h-[720px] 2xl:h-[820px] overflow-hidden">
						<img
							src={getCFImageUrl(displayImage, {
								width: 1920,
								quality: CF_IMAGE_PRESETS.hero.quality,
								format: CF_IMAGE_PRESETS.hero.format,
								fit: CF_IMAGE_PRESETS.hero.fit
							})}
							srcset={generateCFSrcSet(displayImage, CF_IMAGE_PRESETS.hero.widths, CF_IMAGE_PRESETS.hero.quality, CF_IMAGE_PRESETS.hero.format)}
							sizes="100vw"
							alt={cover?.alt || title}
							loading="eager"
							fetchpriority="high"
							decoding="async"
							class="absolute inset-0 h-full w-full object-cover"
						/>
					<div class="absolute inset-0 bg-gradient-to-b from-black/25 via-black/10 to-transparent dark:from-black/40 dark:via-black/25"></div>
					<div class="absolute inset-0 bg-gradient-to-t from-transparent via-white/10 to-white/30 dark:via-white/5 dark:to-white/10 mix-blend-screen"></div>
					</div>
					<div class="pointer-events-none absolute inset-x-0 bottom-0 h-40 xl:h-52 2xl:h-60 bg-gradient-to-b from-transparent via-gray-50/60 to-gray-50 dark:via-gray-950/60 dark:to-gray-950"></div>
				</section>
			)}

			<article class={`relative z-10 ${displayImage ? '-mt-32 sm:-mt-40 lg:-mt-48 xl:-mt-60 2xl:-mt-72' : 'mt-12'}`}>
				<div class="max-w-4xl 2xl:max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 xl:px-10">
					<div class="bg-white/95 dark:bg-gray-900/90 rounded-3xl shadow-2xl shadow-gray-300/40 dark:shadow-black/60 ring-1 ring-gray-200/60 dark:ring-gray-800 backdrop-blur-xl px-6 sm:px-10 xl:px-16 py-10 sm:py-12 xl:py-16">
						<Breadcrumbs items={breadcrumbItems} />

						<header class="text-center mb-10 space-y-6">
							<h1 class="text-4xl sm:text-5xl lg:text-6xl font-extrabold leading-tight tracking-tight text-gray-900 dark:text-gray-100">
								{title}
							</h1>

							<!-- Enhanced Author Info Box -->
							<div class="bg-blue-50/50 dark:bg-blue-950/20 backdrop-blur-sm border border-blue-200/60 dark:border-blue-800/40 rounded-2xl p-5 shadow-sm">
								<div class="flex items-start gap-4">
									<!-- Avatar Section -->
									<div class="relative flex-shrink-0">
										<div class={`absolute -inset-0.5 bg-gradient-to-r from-current to-current rounded-full opacity-60 blur-sm ${avatarGlowColor}`}></div>
										<img
											src={avatarSrc}
											alt={authorName}
											class="relative w-16 h-16 rounded-full ring-3 ring-white dark:ring-gray-900 shadow-md object-cover"
											onError={`this.onerror=null; this.src='${avatarFallback}';`}
										/>
									</div>

									<!-- Info Section -->
									<div class="flex-1 min-w-0 space-y-2.5">
										<!-- Author Name & Meta Info (same line) -->
										<div class="flex flex-wrap items-center gap-x-3 gap-y-1">
											<span class="font-bold text-lg text-gray-900 dark:text-gray-100">
												{authorName}
											</span>
											<span class="flex items-center gap-1.5 text-sm text-gray-600 dark:text-gray-400">
												<svg class="w-3.5 h-3.5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
												</svg>
												<FormattedDate date={pubDate} />
											</span>
											{readingTime && (
												<>
													<span class="text-gray-400 dark:text-gray-600 text-sm">•</span>
													<span class="flex items-center gap-1.5 text-sm text-gray-600 dark:text-gray-400">
														<svg class="w-3.5 h-3.5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
															<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
														</svg>
														<ReadingTime minutes={readingTime} />
													</span>
												</>
											)}
											{filePath && (
												<>
													<span class="text-gray-400 dark:text-gray-600 text-sm">•</span>
													<a
														href={editUrl}
														rel="noopener noreferrer edit"
														target="_blank"
														class="hover:text-blue-600 dark:hover:text-blue-400 transition-colors inline-flex items-center gap-1.5 text-sm font-medium text-gray-600 dark:text-gray-400"
													>
														<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
															<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
														</svg>
														{EDIT_POST.text}
													</a>
												</>
											)}
										</div>

										<!-- Tags -->
										{tags.length > 0 && (
											<div class="flex flex-wrap gap-2">
												{tags.slice(0, 8).map((tag) => (
													<a
														href={getTagUrl(tag)}
														class={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${getTagColorClasses(tag)} transition-all hover:scale-105 hover:shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500/50`}
														onclick="event.stopPropagation()"
													>
														{getTagDisplayName(tag)}
													</a>
												))}
											</div>
										)}

										<!-- Updated Date -->
										{updatedDate && (
											<div class="text-xs text-gray-600 dark:text-gray-400 italic">
												Last updated: <FormattedDate date={updatedDate} />
											</div>
										)}
									</div>
								</div>
							</div>
						</header>

						{showToc && headings.length > 0 && (
							<TableOfContents headings={headings} />
						)}

						<div class="prose mx-auto">
							<slot />
						</div>

						{!isTune && <ShareButtons title={title} url={Astro.url.href} tags={tags} />}

						{!isTune && entry && <RelatedPosts currentPost={entry} previousPost={previousPost} nextPost={nextPost} limit={3} />}
					</div>

					<PostNavigation previousPost={previousPost} nextPost={nextPost} />

					{!isTune && <Comments />}
				</div>
			</article>
		</main>
		<Footer />
		<script>
			import type { LightGallerySettings } from 'lightgallery/lg-settings';
			import type { AstroLightGalleryPluginStrType } from 'astro-lightgallery';

			// Initialize LightGallery for blog post pages with optimized DOM operations
			async function initLightGallery() {
				// Use requestAnimationFrame to batch DOM reads and avoid forced reflows
				requestAnimationFrame(async () => {
					const galleries = document.querySelectorAll('astro-lightgallery');

					// Early exit if no galleries - don't load the library at all
					if (galleries.length === 0) {
						return;
					}

					// Dynamic import - only load LightGallery when galleries exist
					const { createLightGallery } = await import('astro-lightgallery');

					// Batch all DOM reads first to avoid layout thrashing
					const galleryData: Array<{
						htmlGallery: HTMLElement;
						items: HTMLElement[];
						options?: LightGallerySettings;
						addPlugins?: AstroLightGalleryPluginStrType[];
					}> = [];

					let firstGalleryOptions: LightGallerySettings = {};
					let firstGalleryPlugins: AstroLightGalleryPluginStrType[] = [];

					for (const gallery of galleries) {
						const htmlGallery = gallery as HTMLElement;

						// Skip if already initialized
						if (htmlGallery.hasAttribute('data-lg-initialized')) {
							continue;
						}

						// Read options (first gallery only)
						if (galleryData.length === 0) {
							firstGalleryOptions = JSON.parse(htmlGallery.dataset.options || '{}');
							firstGalleryPlugins = JSON.parse(htmlGallery.dataset.addplugins || '[]');
						}

						// Collect all items
						const items = Array.from(htmlGallery.querySelectorAll<HTMLElement>('a[data-lg-id]'));

						galleryData.push({
							htmlGallery,
							items,
							options: firstGalleryOptions,
							addPlugins: firstGalleryPlugins
						});
					}

					// Now do all DOM writes in a single batch
					if (galleryData.length > 0) {
						// Flatten all items
						const allGalleryItems = galleryData.flatMap(g => g.items);

						if (allGalleryItems.length === 0) {
							return;
						}

						// Create unified gallery container
						const unifiedGalleryId = 'unified-lightgallery';
						let unifiedGallery = document.getElementById(unifiedGalleryId);

						if (!unifiedGallery) {
							unifiedGallery = document.createElement('div');
							unifiedGallery.id = unifiedGalleryId;
							unifiedGallery.style.display = 'none';
							document.body.appendChild(unifiedGallery);
						}

						// Clear and populate unified gallery
						unifiedGallery.innerHTML = '';
						const fragment = document.createDocumentFragment();
						allGalleryItems.forEach(item => {
							const clone = item.cloneNode(true) as HTMLElement;
							fragment.appendChild(clone);
						});
						unifiedGallery.appendChild(fragment);

						// Mark galleries as initialized
						galleryData.forEach(({ htmlGallery }) => {
							htmlGallery.setAttribute('data-lg-initialized', 'true');
						});

						// Initialize unified gallery
						await createLightGallery(unifiedGalleryId, firstGalleryOptions, firstGalleryPlugins);

						// Redirect clicks from original galleries to unified gallery
						allGalleryItems.forEach((item, index) => {
							item.addEventListener('click', (e) => {
								e.preventDefault();
								const unifiedItems = unifiedGallery!.querySelectorAll('a[data-lg-id]');
								if (unifiedItems[index]) {
									(unifiedItems[index] as HTMLElement).click();
								}
							});
						});
					}
				});
			}

			// Initialize on first load
			initLightGallery();

			// Re-initialize after View Transitions navigation (cleanup is handled globally in BaseLayout)
			document.addEventListener('astro:page-load', () => {
				// Use requestIdleCallback for better performance, fallback to microtask
				if ('requestIdleCallback' in window) {
					requestIdleCallback(() => initLightGallery(), { timeout: 2000 });
				} else {
					Promise.resolve().then(() => initLightGallery());
				}
			});
		</script>
	</body>
</html>
