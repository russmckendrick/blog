---
import { Head } from '@felixicaza/astro-capo';
import BaseHead from '../components/layout/BaseHead.astro';
import Header from '../components/layout/Header.astro';
import HeaderWrapper from '../components/layout/HeaderWrapper.astro';
import Footer from '../components/layout/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';

// Import embed components to make them available
import { YouTube } from '@astro-community/astro-embed-youtube';
import { LinkPreview } from '@astro-community/astro-embed-link-preview';

import { WebVitals } from '@casoon/astro-webvitals';

interface Props {
	title?: string;
	description?: string;
	image?: any;
	keywords?: string[];
}

const {
	title = SITE_TITLE,
	description = SITE_DESCRIPTION,
	image,
	keywords
} = Astro.props;

const pageTitle = title === SITE_TITLE ? title : `${title} | ${SITE_TITLE}`;
---

<!doctype html>
<html lang="en">
	<Head>
		<BaseHead title={pageTitle} description={description} image={image} keywords={keywords} />
		<slot name="head" />
	</Head>
	<body class="bg-gray-50 dark:bg-gray-950">
		<HeaderWrapper autoHide={false}>
			<Header />
		</HeaderWrapper>
		<main class="mt-10 sm:mt-14">
			<slot />
		</main>
		<Footer />
		<WebVitals debug={import.meta.env.DEV} />
		<script>
			// Defer non-critical work until after LCP using requestIdleCallback
			function scheduleIdleWork(callback: () => void, timeout = 2000) {
				if ('requestIdleCallback' in window) {
					requestIdleCallback(callback, { timeout });
				} else {
					// Fallback: schedule after paint + small delay
					requestAnimationFrame(() => setTimeout(callback, 50));
				}
			}

			// Fix accessibility: Add aria-labels to buttons missing them
			function fixButtonAccessibility() {
				// Find buttons without aria-label
				const buttons = document.querySelectorAll('button:not([aria-label])');
				buttons.forEach(btn => {
					// Skip if button has meaningful text content (but not just whitespace/icons)
					const textContent = btn.textContent?.trim().replace(/[\u200B-\u200D\uFEFF]/g, '');
					if (textContent && textContent.length > 1 && textContent.length < 50 && !/^[●○•◦]+$/.test(textContent)) {
						return; // Has visible text, should be accessible
					}

					// Use title attribute if available
					const title = btn.getAttribute('title');
					if (title) {
						btn.setAttribute('aria-label', title);
						return;
					}

					// Check for Expressive Code copy button (has data-copied attribute or is in .copy wrapper)
					if (btn.hasAttribute('data-copied') || btn.closest('.copy') || btn.querySelector('[data-code]')) {
						btn.setAttribute('aria-label', 'Copy code to clipboard');
						return;
					}

					// Check for common copy button patterns
					const classList = btn.className || '';
					if (classList.includes('copy')) {
						btn.setAttribute('aria-label', 'Copy to clipboard');
					} else if (classList.includes('close')) {
						btn.setAttribute('aria-label', 'Close');
					} else if (classList.includes('expand')) {
						btn.setAttribute('aria-label', 'Expand');
					} else if (classList.includes('collapse')) {
						btn.setAttribute('aria-label', 'Collapse');
					} else if (classList.includes('tab')) {
						// Tab buttons - use text content or data attribute
						const tabText = btn.textContent?.trim() || btn.getAttribute('data-tab') || 'Tab';
						btn.setAttribute('aria-label', tabText);
					} else if (btn.closest('.expressive-code') || btn.closest('[data-language]') || btn.closest('figure.frame')) {
						// Expressive Code buttons - check for common patterns
						if (btn.querySelector('svg') && !textContent) {
							// SVG icon button - likely copy button
							btn.setAttribute('aria-label', 'Copy code to clipboard');
						}
					}
				});

				// Fix links without accessible text (icon-only links)
				const links = document.querySelectorAll('a:not([aria-label])');
				links.forEach(link => {
					const textContent = link.textContent?.trim();
					if (textContent && textContent.length > 0) {
						return; // Has visible text
					}

					// Use title if available
					const title = link.getAttribute('title');
					if (title) {
						link.setAttribute('aria-label', title);
					}
				});
			}

			// Fix accessibility: Ensure scrollable code blocks have tabindex
			// Only runs on pages with code blocks, batches layout reads to avoid forced reflow
			function fixCodeBlockTabindex() {
				const preElements = document.querySelectorAll('.expressive-code pre');
				// Skip if no code blocks on page (e.g., homepage)
				if (preElements.length === 0) return;

				// Batch all layout reads first to avoid forced reflow
				const elementsToFix: HTMLElement[] = [];
				preElements.forEach(pre => {
					if (!pre.hasAttribute('tabindex')) {
						// Read all dimensions in one batch
						const scrollWidth = pre.scrollWidth;
						const clientWidth = pre.clientWidth;
						if (scrollWidth > clientWidth) {
							elementsToFix.push(pre as HTMLElement);
						}
					}
				});

				// Then batch all writes
				elementsToFix.forEach(pre => {
					pre.setAttribute('tabindex', '0');
					pre.setAttribute('role', 'region');
				});
			}

			// Defer accessibility fixes until after LCP (don't block initial render)
			scheduleIdleWork(fixButtonAccessibility, 1500);

			// Re-run after View Transitions and DOM updates
			document.addEventListener('astro:page-load', () => {
				scheduleIdleWork(fixButtonAccessibility, 1500);
				// Run code block fix after Expressive Code's debounced observer
				scheduleIdleWork(fixCodeBlockTabindex, 2000);
			});

			// Single deferred check for dynamically loaded content
			scheduleIdleWork(() => {
				fixButtonAccessibility();
				fixCodeBlockTabindex();
			}, 2500);

			// Use MutationObserver but with longer debounce and idle scheduling
			let mutationTimeout: number | undefined;
			const observer = new MutationObserver((mutations) => {
				let shouldFix = false;
				for (const mutation of mutations) {
					if (mutation.addedNodes.length > 0) {
						shouldFix = true;
						break;
					}
				}
				if (shouldFix) {
					// Longer debounce to batch mutations
					clearTimeout(mutationTimeout);
					mutationTimeout = window.setTimeout(() => {
						scheduleIdleWork(fixButtonAccessibility, 500);
					}, 250);
				}
			});

			// Delay observer attachment until after initial render
			scheduleIdleWork(() => {
				observer.observe(document.body, {
					childList: true,
					subtree: true
				});
			}, 1000);

			// Global cleanup for LightGallery when navigating away from pages
			function cleanupLightGallery() {
				// Remove unified gallery container
				const unifiedGallery = document.getElementById('unified-lightgallery');
				if (unifiedGallery) {
					unifiedGallery.remove();
				}

				// Remove ALL LightGallery elements (comprehensive cleanup)
				const lgSelectors = [
					'.lg-outer',
					'.lg-backdrop',
					'.lg-container',
					'#lg-backdrop',
					'#lg-outer',
					'[class^="lg-"]',
					'[id^="lg-"]'
				];

				lgSelectors.forEach(selector => {
					const elements = document.querySelectorAll(selector);
					elements.forEach(el => el.remove());
				});

				// Also check for any elements directly attached to body that might be LightGallery-related
				const bodyChildren = Array.from(document.body.children);
				bodyChildren.forEach(child => {
					const el = child as HTMLElement;
					if (el.className && typeof el.className === 'string' && el.className.includes('lg-')) {
						el.remove();
					}
				});

				// Reset initialization flags on all galleries
				const galleries = document.querySelectorAll('astro-lightgallery[data-lg-initialized]');
				galleries.forEach(gallery => {
					gallery.removeAttribute('data-lg-initialized');
				});
			}

			// Cleanup before View Transitions swap
			document.addEventListener('astro:before-swap', () => {
				cleanupLightGallery();
			});
		</script>
	</body>
</html>
